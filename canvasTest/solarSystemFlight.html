<!DOCTYPE HTML>
<html>
<head>
    <style>
        body {
            margin: 0px;
            padding: 0px;
        }
    </style>
</head>
<body style="width: 100%; height: 100%">

<table>
    <tr>
        <td width="700">
            <canvas id="myCanvas" width="700" height="700"></canvas>
        </td>
        <td width="*">
            <div><input type="checkbox" id="gravityOnOff" name="gravityOnOff" checked /> Gravity</div>
            <div><input type="checkbox" id="autopilotOnOff" name="autopilotOnOff" />Autopilot</div>
        </td>
    </tr>
</table>
<script>


    function loadImages(sources, callback) {
        var images = {};
        var loadedImages = 0;
        var numImages = 0;
        // get num of sources
        for (var src in sources) {
            numImages++;
        }
        for (var src in sources) {
            images[src] = new Image();
            images[src].onload = function() {
                if (++loadedImages >= numImages) {
                    callback(images);
                }
            };
            images[src].src = sources[src];
        }
    }

    var canvas = document.getElementById('myCanvas');
    var gravityOnOff = document.getElementById('gravityOnOff');
    var autopilotOnOff = document.getElementById('autopilotOnOff');
    var context = canvas.getContext('2d');
    var gravitationalConstant = 10;

    var sources = {
        ship1: 'ship1.png'
    };

    var rawPlanets = [

        // from: http://www.telescope.org/nuffield/pas/solar/solar7.html
        // add http://www.astronomynotes.com/tables/tablesb.htm
        //Planet      Distance           Mass         Time for 1       
        //            from               of Planet    Orbit              
        //            Sun                (x10 ^22 kg) of Sun
        //            (million km)                    (days)       
        { name: "Sun", distance: 0, mass: 1.989E30, diameter: 1.392E6 },
        { name: "Mercury", distance: 58E9, mass: 33.0E22, diameter: 4879 },
        { name: "Venus", distance: 108E9, mass: 487E22, diameter: 12104 },
        { name: "Earth", distance: 150E9, mass: 598E22, diameter: 12742 },
        { name: "Mars", distance: 228E9, mass: 64.2E22, diameter: 6779 }
    ];

//Jupiter            778            190,000          4332          

//        Saturn             1,429          56,900           10760 

//        Uranus             2,871          8,690            30700         

//        Neptune            4,504          10,280           60200         

//        Pluto              5,913          1.49             90600         

    var planets = [];
    rawPlanets.forEach(function(rp) {
        planets.push({
            name: rp.name,
            distance: Math.pow(rp.distance, 0.3),
            mass: Math.pow(rp.mass, 0.25),
            radius: Math.pow(rp.diameter, 0.5) / 2,
            x: 0,
            y: 0
        });
    });
    var massOfSun = planets[0].mass;
    planets.forEach(function(p) {
        if (p.distance > 0) {
            p.orbit = Math.sqrt(gravitationalConstant * massOfSun / Math.pow(p.distance, 3));
        } else {
            p.orbit = 0;
        }
    });

    var ship = {
        thrust: 100, //  pixels/sec/sec
        rotatespeed: 180, // degrees per second
        x: planets[1].distance,
        y: 0,
        dx: 0,
        // https://en.wikipedia.org/wiki/Circular_orbit  to calculate v to get a circular orbit
        dy: Math.sqrt(gravitationalConstant * planets[0].mass / (planets[1].distance)),
        r: 0, // direction pointed
        isThrusting: false,
        isRotateRight: false,
        isRotateLeft: false,
        history: []
    };

    var scaleMillisecondsPerDay = 1000;

    function keyDownHandler() {
        var keyPressed = String.fromCharCode(event.keyCode);
        if (keyPressed == 'W') {
            ship.isThrusting = true;
        } else if (keyPressed == 'A') {
            ship.isRotatingLeft = true;
        } else if (keyPressed == 'D') {
            ship.isRotatingRight = true;
        }
    }

    function keyUpHandler() {
        var keyPressed = String.fromCharCode(event.keyCode);
        if (keyPressed == 'W') {
            ship.isThrusting = false;
        } else if (keyPressed == 'A') {
            ship.isRotatingLeft = false;
        } else if (keyPressed == 'D') {
            ship.isRotatingRight = false;
        }
    }

    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    loadImages(sources, function(images) {

        var prevtimestamp = null;
        var desiredFps = 60;
        var desiredGap = 1000 / desiredFps;
        var lastFiredGap = 0;
        context.font = "20px Arial";

        // timestamp is milliseconds since we started..
        function animate(timestamp) {

            requestAnimationFrame(animate);

            var currentGap = (timestamp - lastFiredGap);
            if (currentGap < desiredGap) {
                return;
            } else {
                lastFiredGap = timestamp;
            }

            var elapsed = 1;
            var avgelapsed = 1;
            var FPS = 1;
            if (prevtimestamp) {
                elapsed = (timestamp - prevtimestamp);
                if (elapsed > 1000) return;
                avgelapsed = elapsed * 0.01 + avgelapsed * 0.99;
                FPS = Math.round(1000 / avgelapsed);
            }
            prevtimestamp = timestamp;
            context.clearRect(0, 0, canvas.width, canvas.height);

            var d = new Date();
            var ageOfUniverseInDays = d.getTime() / scaleMillisecondsPerDay;
            planets.forEach(function(p) {
                if (p.orbit > 0) {
                    var angle = p.orbit * ageOfUniverseInDays;
                    p.x = Math.cos(angle) * p.distance;
                    p.y = Math.sin(angle) * p.distance;
                } else {
                    p.x = 0;
                    p.y = 0;
                }
            });

            context.save();
            {
                // we want 0 to end up at canvas.width/2 
                context.translate(canvas.width / 2, canvas.height / 2);
                context.scale(1, -1); // flip the y axis so that - is below and + is above. 

                var absStartX = ship.x - 600;
                var absStartY = ship.y - 400;
                absStartX = Math.floor(absStartX / 100) * 100;
                absStartY = Math.floor(absStartY / 100) * 100;
                for (var x = absStartX; x < ship.x + 600; x += 100) {
                    for (var y = absStartY; y < ship.y + 400; y += 100) {
                        context.fillRect(x - ship.x, y - ship.y, 1, 1);
                    }
                }
                // context.fillRect(-400, -300, 20, 10);

                planets.forEach(function(p) {
                    context.beginPath();
                    context.arc(p.x - ship.x, p.y - ship.y, p.radius, 0, 2 * Math.PI, false);
                    context.stroke();
                    context.fillText(p.name, p.x - ship.x, p.y - ship.y);
                });

                ship.history.forEach(function(h) {
                    context.fillRect(h.x - ship.x, h.y - ship.y, 1, 1);
                });

                context.save();
                {
                    context.rotate((180 - ship.r) * Math.PI / 180);
                    context.drawImage(images.ship1, -images.ship1.width / 2, -images.ship1.height / 2);
                }
                context.restore();

                context.beginPath();
                context.moveTo(0, 0);
                context.lineTo(ship.dx, ship.dy);
                context.stroke();

                // start control section

                if (autopilotOnOff.checked) {
                    // figure out closest planetary body
                    var closestPlanet = null;
                    var closestPlanetDsq = null;
                    planets.forEach(function (p) {
                        var dx = p.x - ship.x;
                        var dy = p.y - ship.y;
                        var rsq = dx * dx + dy * dy;
                        if (closestPlanetDsq == null || rsq < closestPlanetDsq) {
                            closestPlanet = p;
                            closestPlanetDsq = rsq;
                        }
                    });
                    if (closestPlanet != null) {
                        var dx = closestPlanet.x - (ship.x + (ship.dx * 20));
                        var dy = closestPlanet.y - (ship.y + (ship.dy * 20));
                        var mag = Math.sqrt(dx * dx + dy * dy);
                        var mymag = Math.sqrt(ship.dx * ship.dx + ship.dy * ship.dy);

                        // 1. figure out direction. 
                        var angleRadians = Math.atan2(dy, dx);
                        var angleDegrees = angleRadians * 180 / Math.PI;
                        var angleToGo = angleDegrees - ship.r;
                        while (angleToGo < -180) {
                            angleToGo = angleToGo + 180;
                        }
                        while (angleToGo > 180) {
                            angleToGo = angleToGo - 180;
                        }
                        ship.isRotatingRight = false;
                        ship.isRotatingLeft = false;
                        ship.isThrusting = false; 
                        if (angleToGo < -1) {
                            ship.isRotatingLeft = true;
                        }
                        if (angleToGo > 1) {
                            ship.isRotatingRight = true; 
                        }
                        if (angleToGo > -5 && angleToGo < 5 && mymag*10 < mag) {
                            ship.isThrusting = true; 
                        }
                    }
                }

                if (ship.isThrusting) {
                    var vecx = Math.sin(ship.r * Math.PI / 180) * ship.thrust;
                    var vecy = Math.cos(ship.r * Math.PI / 180) * ship.thrust;
                    ship.dx = ship.dx + vecx * (elapsed / 1000);
                    ship.dy = ship.dy + vecy * (elapsed / 1000);
                    context.beginPath();
                    context.moveTo(0, 0);
                    context.strokeStyle = "#0000ff";
                    context.lineTo(vecx, vecy);
                    context.stroke();

                }

                if (ship.isRotatingRight) {
                    // elapsed ms
                    ship.r = ship.r + (elapsed / 1000) * ship.rotatespeed;
                    while (ship.r < 0) ship.r = ship.r + 360;

                }

                if (ship.isRotatingLeft) {
                    ship.r = ship.r - (elapsed / 1000) * ship.rotatespeed;
                    while (ship.r > 360) ship.r = ship.r - 360;
                }


                // ship is affected by gravity
                planets.forEach(function(p) {

                    // https://www.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-forces/a/gravitational-attraction
                    // raw form.  can be simplified and use r^3 derived from r^2

                    var dx = p.x - ship.x;
                    var dy = p.y - ship.y;
                    var rsq = dx * dx + dy * dy;
                    if (rsq < 1) rsq = 1;
                    var r = Math.sqrt(rsq);

                    var unitx = dx / r;
                    var unity = dy / r;

                    // prevent crazy launches.  aka, scrape through the atmosphere. 
                    if (r < p.radius) {
                        rsq = p.radius * p.radius;
                    }

                    var gravForce = (gravitationalConstant * p.mass) / rsq;
                    var gravx = unitx * gravForce;
                    var gravy = unity * gravForce;

                    if (gravityOnOff.checked) {
                        ship.dx = ship.dx + gravx * (elapsed / 1000);
                        ship.dy = ship.dy + gravy * (elapsed / 1000);
                    }

                    context.beginPath();
                    context.strokeStyle = "#77ff77";
                    context.moveTo(0, 0);
                    var scaledR = Math.pow(r, 0.25); 
                    context.lineTo(unitx * scaledR, unity * scaledR);
                    context.stroke();

                    context.beginPath();
                    context.strokeStyle = "#ff0000";
                    context.moveTo(0, 0);
                    context.lineTo(gravx, gravy);
                    context.stroke();
                });
            }
            context.restore();

            // ship floats in space based on velocity
            ship.history.push({ x: ship.x, y: ship.y });
            if (ship.history.length > 100000) {
                for (var h = 0; h < ship.history.length / 2 - 1; h++) {
                    ship.history[h] = ship.history[h * 2];
                }
                ship.history.length = ship.history.length / 2;
            }
            ship.x = ship.x + ship.dx * (elapsed / 1000);
            ship.y = ship.y + ship.dy * (elapsed / 1000);

            //while (ship.x > canvas.width) {
            //    ship.x = ship.x - canvas.width;
            //}
            //while (ship.y > canvas.height) {
            //    ship.y = ship.y - canvas.height;
            //}
            //while (ship.x < 0) {
            //    ship.x = ship.x + canvas.width;
            //}
            //while (ship.y < 0) {
            //    ship.y = ship.y + canvas.height;
            //}

            context.fillText(Math.round(timestamp) + " " + Math.round(ship.x) + " " + Math.round(ship.y), 0, canvas.height);
        }

        requestAnimationFrame(animate);

        //document.getElementById("debug").innerHTML = " " + ship.x + " " + ship.y + " " + ship.dx + " " + ship.dy + " " + ship.r;

    });

</script>
</body>
</html>
